% Este código utiliza el .csv generado anteriormente con los puntos
% y en conjunto con la cinemática inversa calcúla el movimiento que
% ocupa hacer el robot
clear; clc; close all;

% Medidas del robot (cm)
a0 = 7.3;
L1 = 19.0;
L2 = 12.1;

% Configuración general
codo    = "up";
archivo_csv = 'Puntos.csv';
DRY_RUN  = false;              % true => no abre puerto, solo simula

%% Leer trayectoria
% El CSV tiene 3 columnas: x_mm, y_mm, z_mm en el marco base del robot
T = readtable(archivo_csv);

if width(T) < 3
    error('El CSV debe tener al menos 3 columnas: x_mm, y_mm, z_mm.');
end

x_cm = T{:,1} ./ 10;   % mm -> cm
y_cm = T{:,2} ./ 10;   % mm -> cm
z_cm = T{:,3} ./ 10;   % mm -> cm

% Reconstruir pen_down a partir de z:
pen = z_cm < 0.5;

% Vector de puntos objetivo en el marco base
x = x_cm;
y = y_cm;

%% IK
N = numel(x);
theta1 = zeros(N,1);
theta2 = zeros(N,1);
reachable = true(N,1);

for i = 1:N
    % Coordenadas respecto al eje de la primera articulación en (0, a0)
    xr = x(i);
    yr = y(i) - a0;

    r2 = xr.^2 + yr.^2;

    % Ley de cosenos
    c2 = (r2 - (L1.^2 + L2.^2)) ./ (-2.0 .* L1 .* L2);

    if c2 > 1
        c2 = 1;
        reachable(i) = false;
    end
    if c2 < -1
        c2 = -1;
        reachable(i) = false;
    end

    s2_mag = sqrt(max(0, 1 - c2.^2));

    % Codo arriba o codo abajo
    Posicion_codo = strcmp(codo,"up") - strcmp(codo,"down");
    if Posicion_codo == 0
        Posicion_codo = 1;
    end
    s2 = s2_mag * Posicion_codo;

    theta2(i) = atan2(s2, c2);

    k1 = L1 - L2 .* c2;
    k2 = L2 .* s2;
    theta1(i) = atan2(yr, xr) + atan2(k2, k1);
end

%% Exportar juntas
seq = (1:N).';

% Invertir el ángulo por posición=]=]s==]===]
theta1_deg_inv = 178 - rad2deg(theta1);
theta2_deg_inv = 90 - rad2deg(theta2);

out = table( ...
    seq, theta1_deg_inv, theta2_deg_inv, pen, ...
    'VariableNames', {'seq','theta1_deg','theta2_deg','pen_down'});

try
    tgt = fullfile(pwd, 'Ángulos.csv');
    if exist(tgt,'file')
        fileattrib(tgt,'+w');
        delete(tgt);
    end
    writetable(out, tgt);
    fprintf('CSV de juntas exportado: %s\n', tgt);
catch ME
    warning('No pude escribir en %s. Error: %s', pwd, ME.message);
    tmpdir = fullfile(tempdir, 'robotica_tray');
    if ~exist(tmpdir,'dir'), mkdir(tmpdir); end
    tgt = fullfile(tmpdir, 'Ángulos.csv');
    writetable(out, tgt);
    fprintf('CSV de juntas exportado en carpeta temporal: %s\n', tgt);
end

%% Verificación
% Primer eje en (0, a0)
x_fk =      L1 .* cos(theta1) - L2 .* cos(theta1 + theta2);
y_fk = a0 + L1 .* sin(theta1) - L2 .* sin(theta1 + theta2);

err = hypot(x_fk - x, y_fk - y);
fprintf('Error cartesiano medio: %.3f cm (max: %.3f cm)\n', mean(err), max(err));

%% Visualización de movimientos
figure('Name','IK Preview (Base Frame)','Color','w');
hold on; axis equal; grid on;

% Trayectoria XY
for i = 2:N
    if pen(i-1)==1 && pen(i)==1
        plot([x(i-1) x(i)], [y(i-1) y(i)], 'r--', 'LineWidth', 1.2);
    else
        plot([x(i-1) x(i)], [y(i-1) y(i)], 'k', 'LineWidth', 1.5);
    end
end

% Dibujar robot cada cierto número de puntos
M = max(1, round(N/50));
for i = 1:M:N
    p1 = [0; a0];   % eje 1 en x=0, y=a0
    p2 = p1 + [L1 .* cos(theta1(i)); L1 .* sin(theta1(i))];
    pE = p2 + [-L2 .* cos(theta1(i)+theta2(i)); -L2 .* sin(theta1(i)+theta2(i))];
    plot([p1(1) p2(1)], [p1(2) p2(2)], 'b-', 'LineWidth', 2);
    plot([p2(1) pE(1)], [p2(2) pE(2)], 'b-', 'LineWidth', 2);
    plot(pE(1), pE(2), 'ko', 'MarkerFaceColor','k', 'MarkerSize', 3);
end

xlabel('X_{base} [cm]');
ylabel('Y_{base} [cm]');
title(sprintf('IK (%s) - error medio %.2f cm', codo, mean(err)));

bad = ~reachable;
if any(bad)
    plot(x(bad), y(bad), 'mo', 'MarkerSize', 6, 'LineWidth', 1.2);
    legend({'DOWN','UP','Robot','EE','No alcanzable'}, 'Location','best');
else
    legend({'DOWN','UP','Robot','EE'}, 'Location','best');
end

%% Comunicación con Arduino
if ~DRY_RUN
    port = "COM3";
    baud = 115200;

    % Posición HOME
    theta1_home = 90.0;   % theta1
    theta2_home = 90.0;   % theta2
    pen_home    = 1;      % marcador arriba

    fprintf('\n[Serial] Abriendo %s @ %d ...\n', port, baud);
    s = serialport(port, baud, "Timeout", 3);
    configureTerminator(s, "LF");
    flush(s);
    pause(0.4);  % deja reiniciar al UNO

    % Esperar READY
    ready = false;
    t0 = tic;
    while toc(t0) < 8
        if s.NumBytesAvailable > 0
            ln = strtrim(readline(s));
            if contains(ln, "READY")
                ready = true;
                break;
            end
        end
        pause(0.05);
    end
    if ~ready
        warning('No llegó READY; continúo.');
    end

    % Homing lógico
    writeline(s, "H");
    pause(0.05);

    % Ir primero a la posición HOME
    homeMsg = sprintf("I,%.3f,%.3f,%d", ...
        theta1_home, theta2_home, pen_home);
    fprintf('[TX HOME] %s\n', homeMsg);
    writeline(s, homeMsg);
    pause(3.0);   % tiempo para que el robot llegue a HOME

    % Enviar trayectoria
    fprintf('[Serial] Enviando %d puntos...\n', N);
    lastPen = pen_home;   % o out.pen_down(1) si prefieres

    for i = 1:N
        pen_i = out.pen_down(i);   % 0 o 1

        % Formato correcto: T,theta1,theta2,pen
        msg = sprintf("T,%.3f,%.3f,%d", ...
            out.theta1_deg(i), out.theta2_deg(i), pen_i);

        % Mostrar en la ventana de comandos
        fprintf('[TX %4d/%4d] %s\n', i, N, msg);
        writeline(s, msg);

        % Tiempo entre puntos según cambio del pen
        if pen_i == lastPen
            pause(1.0);   % no cambió pen → 2 s
        else
            pause(1.0);   % cambió pen (sube/baja) → 5 s
        end

        lastPen = pen_i;

        % Leer respuesta si hay eco del Arduino
        if s.NumBytesAvailable > 0
            readline(s); 
        end
    end
    
    % Volver a HOME al terminar
    homeMsg = sprintf("F,%.3f,%.3f,%d", ...
        theta1_home, theta2_home, pen_home);
    fprintf('[Serial] Trayectoria terminada, volviendo a HOME...\n');
    writeline(s, homeMsg);
    fprintf('[TX HOME END] %s\n', homeMsg);
    pause(2.0);

    fprintf('[Serial] Listo.\n');
    pause(0.02);
    clear s
end
